#pragma once

#include "./details.h"
#include "./equal_ip.h"
#include "./types.h"

// for matrix n*s, open com(row) and com(col), prove consistency of them.
// That is, prove they were generated by same matrix.

namespace pc_utils::matrix::details {
inline void UpdateSeed(h256_t& seed, std::vector<G1> const& c1,
                       std::vector<G1> const& c2) {
  CryptoPP::Keccak_256 hash;
  HashUpdate(hash, seed);
  HashUpdate(hash, c1);
  HashUpdate(hash, c2);
  hash.Final(seed.data());
}
}  // namespace pc_utils::matrix::details

namespace pc_utils::matrix {

using Proof = equal_ip::Proof;

inline void Prove(Proof& proof, h256_t seed, GetMatrix const& get_m,
                  std::vector<G1> const& com_rows,
                  std::vector<Fr> const& com_row_rs,
                  std::vector<G1> const& com_cols,
                  std::vector<Fr> const& com_col_rs) {
  int64_t n = (int64_t)com_rows.size();
  int64_t s = (int64_t)com_cols.size();
  assert(n == (int64_t)com_row_rs.size());
  assert(s == (int64_t)com_col_rs.size());

  details::UpdateSeed(seed, com_rows, com_cols);
  std::vector<Fr> d(n);
  ComputeFst(seed, "consistency::matrix::d", d);
  std::vector<Fr> e(s);
  ComputeFst(seed, "consistency::matrix::e", e);

  std::array<parallel::Task, 2> tasks;
  std::vector<Fr> v(s, FrZero());
  G1 com_v;
  Fr com_v_r;
  tasks[0] = [n, s, &d, &v, &get_m, &com_rows, &com_row_rs, &com_v,
              &com_v_r]() {
    for (int64_t j = 0; j < s; ++j) {
      for (int64_t i = 0; i < n; ++i) {
        v[j] += d[i] * get_m(i, j);
      }
    }
    // compute com(v)
    com_v = MultiExpBdlo12(com_rows, d);
    com_v_r = InnerProduct(com_row_rs, d);

#ifdef _DEBUG
    G1 check_com_v = PcComputeCommitment(v, com_v_r);
    assert(com_v == check_com_v);
#endif
  };

  std::vector<Fr> w(n, FrZero());
  G1 com_w;
  Fr com_w_r;
  tasks[1] = [n, s, &e, &w, &get_m, &com_cols, &com_col_rs, &com_w,
              &com_w_r]() {
    for (int64_t i = 0; i < n; ++i) {
      for (int64_t j = 0; j < s; ++j) {
        w[i] += e[j] * get_m(i, j);
      }
    }
    // compute com(w)
    com_w = MultiExpBdlo12(com_cols, e);
    com_w_r = InnerProduct(com_col_rs, e);

#ifdef _DEBUG
    G1 check_com_w = PcComputeCommitment(w, com_w_r);
    assert(com_w == check_com_w);
#endif
  };

  parallel::Invoke(tasks);

  Fr z = InnerProduct(v, e);
  assert(z == InnerProduct(w, d));
  equal_ip::Prove(proof, seed, v, e, com_v, com_v_r, w, d, com_w, com_w_r, z);
}

inline bool Verify(h256_t seed, std::vector<G1> const& com_rows,
                   std::vector<G1> const& com_cols, Proof const& proof) {
  int64_t n = (int64_t)com_rows.size();
  int64_t s = (int64_t)com_cols.size();

  details::UpdateSeed(seed, com_rows, com_cols);

  std::vector<Fr> d(n);
  ComputeFst(seed, "consistency::matrix::d", d);
  std::vector<Fr> e(s);
  ComputeFst(seed, "consistency::matrix::e", e);

  std::array<parallel::Task, 2> tasks;

  G1 com_v;
  tasks[0] = [&proof, &com_rows, &d, &com_v]() {
    com_v = MultiExpBdlo12(com_rows, d);
  };

  G1 com_w;
  tasks[1] = [&proof, &com_cols, &e, &com_w]() {
    com_w = MultiExpBdlo12(com_cols, e);
  };

  parallel::Invoke(tasks);

  return equal_ip::Verify(seed, e, com_v, d, com_w, proof);
}

inline bool Test() {
  auto seed = misc::RandH256();
  int64_t n = 10;
  int64_t s = 3;
  std::vector<Fr> m(n * s);
  std::vector<Fr> com_row_rs(n);
  std::vector<Fr> com_col_rs(s);
  FrRand(m);
  FrRand(com_row_rs);
  FrRand(com_col_rs);
  std::vector<G1> com_rows(n);
  std::vector<G1> com_cols(s);
  for (int64_t i = 0; i < n; ++i) {
    com_rows[i] = PcComputeCommitment(
        s, [s, i, &m](int64_t j) -> Fr const& { return m[i * s + j]; },
        com_row_rs[i]);
  }
  for (int64_t j = 0; j < s; ++j) {
    com_cols[j] = PcComputeCommitment(
        n, [s, j, &m](int64_t i) -> Fr const& { return m[i * s + j]; },
        com_col_rs[j]);
  }

  auto get_m = [&m, s](int64_t i, int64_t j) -> Fr const& {
    return m[i * s + j];
  };

  Proof proof;
  Prove(proof, seed, get_m, com_rows, com_row_rs, com_cols, com_col_rs);

  if (!Verify(seed, com_rows, com_cols, proof)) {
    assert(false);
    return false;
  }
  return true;
}
}  // namespace pc_utils::matrix